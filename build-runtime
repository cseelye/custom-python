#!/usr/bin/env bash
set -euETo pipefail
shopt -s inherit_errexit

SECONDS=0

PYTHON_VERSION=${PYTHON_VERSION-3.11.4}
PACKAGE_NAME=${PACKAGE_NAME-prt.tgz}
PACKAGE_NAME_DEV=${PACKAGE_NAME_DEV-prt-dev.tgz}
PRT_ROOT=${PRT_ROOT-/prt}
OUTPUT_DIR=${OUTPUT_DIR-/output}
RUNTIME_VER=${RUNTIME_VER-v0}
CACHE_URL=http://localhost:9000/prt/cache
MTUNE=${MTUNE-icelake-server}

USE_CACHE=${USE_CACHE-1}

COLOR_ESC="\e["
COLOR_OFF="${COLOR_ESC}0m"
COLOR_BOLD="${COLOR_ESC}1m"
COLOR_FAINT="${COLOR_ESC}2m"
RESET="\e[39;49;00m"
BLACK="${COLOR_ESC}30m$COLOR_BOLD"
RED="${COLOR_ESC}31m$COLOR_BOLD"
GREEN="${COLOR_ESC}32m$COLOR_BOLD"
YELLOW="${COLOR_ESC}33m$COLOR_BOLD"
BLUE="${COLOR_ESC}34m$COLOR_BOLD"
MAGENTA="${COLOR_ESC}35m$COLOR_BOLD"
CYAN="${COLOR_ESC}36m$COLOR_BOLD"
WHITE="${COLOR_ESC}37m$COLOR_BOLD"

color() {
    echo -e "${1}${2}${COLOR_OFF}"
}
indent() {
    spaces=${1-4}
    sed -u "s/^/$(printf "%${spaces}s")/";
}

log() {
    if [[ $# -eq 0 ]] ; then
        while IFS= read -r line ; do
            # printf "$(date) | %s\n" "${line}"
            echo "$(date) | ${line}"
        done
    else
        echo "$(date) | $@"
    fi
}

delay_shutdown() {
    echo
    date -ud "@$SECONDS" "+Total runtime: %Hh%Mm%Ss"
    # This is a hack to allow a little time for the log function to finish and flush stdout
    #   before the script exits and container shuts down, otherwise the gitlab runner tends to
    #   kill the script and lose the last bit of output
    sleep 0.5
}
trap 'set +x; delay_shutdown' EXIT ERR

# Redirect all stdout/stderr from here on, to the log function
exec &> >(log)

# Change to the directory the script file is in
SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
pushd "${SCRIPT_DIR}" &>/dev/null

color ${CYAN} "===================================================="
color ${CYAN} "        Building Python Runtime $(uname -m)"
color ${CYAN} "===================================================="
echo

color ${MAGENTA} "* * * Building base python runtime version ${PYTHON_VERSION}"
( time (
mkdir -p "${PRT_ROOT}"
# Try to download a cached build of python
CACHE_FILE="cache_prt_python_${PYTHON_VERSION}_$(uname -m).tgz"
if [[ ${USE_CACHE} -eq 1 ]] && curl -fsSL --head ${CACHE_URL}/${CACHE_FILE} &>/dev/null; then
    echo "Downloading cached build for python ${PYTHON_VERSION}"
    curl -fsSL ${CACHE_URL}/${CACHE_FILE} -o /tmp/python.tgz
    tar -xzf /tmp/python.tgz -C "${PRT_ROOT}"
else
# Build the python runtime
    export PYTHON_CONFIGURE_OPTS='--enable-optimizations --with-lto'
    if [[ -n ${MTUNE} ]]; then
        export PYTHON_CFLAGS="-mtune=${MTUNE}"
    fi
    export PROFILE_TASK='-m test.regrtest --pgo -j0'
    VERBOSE=""
    if [[ -n ${CI-} || -n ${V-} ]]; then
        VERBOSE="--verbose"
    fi

    if [[ -n "$(find pre-patch -name  "*.patch" 2>/dev/null || true)" ]]; then
        cat  pre-patch/*.patch | python-build -p ${VERBOSE} ${PYTHON_VERSION} "${PRT_ROOT}"
    else
        python-build ${VERBOSE} ${PYTHON_VERSION} "${PRT_ROOT}"
    fi
    echo
    echo ">>> Updating python cache object"
    tar -czf /tmp/${CACHE_FILE} -C "${PRT_ROOT}" $(ls -A "${PRT_ROOT}")
    mv /tmp/${CACHE_FILE} "${OUTPUT_DIR}/"
    ls -lh  "${OUTPUT_DIR}/${CACHE_FILE}"
fi
) ) 2>&1 | indent
echo

# Apply any post-patches
for patch_file in $(find ./post-patch -type f -name "*.patch" -exec readlink -f {} \; | sort -V); do
    color ${MAGENTA} "* * * Applying patch $(basename ${patch_file})"
    ( time patch -d "${PRT_ROOT}" -p2 < "${patch_file}" ) 2>&1 | indent
    echo
done

# Download the pip cache to preload it
PIP_CACHE_FILE="cache_prt_pip_$(uname -m).tgz"
mkdir -p /root/.cache
if [[ ${USE_CACHE} -eq 1 ]]; then
    if curl -fsSL --head ${CACHE_URL}/${PIP_CACHE_FILE} &>/dev/null; then
        echo ">>> Preloading pip cache"
        curl -fsSL ${CACHE_URL}/${PIP_CACHE_FILE} | tar -xz -C /root/.cache || true
        echo
    fi
fi

# Configure pip and install python packages
cp ./pip.conf "${PRT_ROOT}"
for req_file in $(find ./python-requirements -type f -name "*.txt" -exec readlink -f {} \; | sort -V); do
    color ${MAGENTA} "* * * Installing packages from $(basename ${req_file})"
    ( time "${PRT_ROOT}"/bin/pip install --upgrade --force-reinstall --requirement "${req_file}" ) 2>&1 | indent
    echo
done

echo ">>> Updating pip cache object"
(
echo
tar -czf /tmp/${PIP_CACHE_FILE} -C /root/.cache pip
mv /tmp/${PIP_CACHE_FILE} ${OUTPUT_DIR}/
echo
) 2>&1 | indent

# Create a manifest
"${PRT_ROOT}"/bin/pip list --format=json | jq '{"python_packages": .}' \
    | jq '. += {"python_version": "'${PYTHON_VERSION}'", "runtime_version": "'${RUNTIME_VER}'"}' \
    > "${PRT_ROOT}"/manifest.json

# Create the package archive
color ${MAGENTA} "* * * Creating package"
tmpfile="$(mktemp)"
( time (
tar -czf "${tmpfile}" -C "${PRT_ROOT}" $(ls -A "${PRT_ROOT}")
chmod +r "${tmpfile}"
mv "${tmpfile}" "${OUTPUT_DIR}/${PACKAGE_NAME}"
cp "${PRT_ROOT}/manifest.json" "${OUTPUT_DIR}/${PACKAGE_NAME%%.*}.manifest.json"
ls -lh "${OUTPUT_DIR}/${PACKAGE_NAME%%.*}"*
) ) 2>&1 | indent


echo
echo
color ${CYAN} "===================================================="
color ${CYAN} "     Building Python Runtime (DEV) $(uname -m)"
color ${CYAN} "===================================================="
echo

# Apply any patches
for patch_file in $(find ./dev/patch -type f -name "*.patch" -exec readlink -f {} \; | sort -V || true 2>/dev/null); do
    color ${MAGENTA} "* * * Applying patch $(basename ${patch_file})"
    ( time patch -d "${PRT_ROOT}" -p2 <  "${patch_file}" ) 2>&1 | indent
    echo
done

# Download the pip cache to preload it
PIP_DEV_CACHE_FILE="cache_prt_dev_pip_$(uname -m).tgz"
mkdir -p /root/.cache
if curl -fsSL --head ${CACHE_URL}/${PIP_DEV_CACHE_FILE} &>/dev/null; then
    echo ">>> Preloading dev pip cache"
    curl -fsSL ${CACHE_URL}/${PIP_DEV_CACHE_FILE} | tar -xz -C /root/.cache || true
    echo
fi

# Install python packages
for req_file in $(find ./dev/requirements -type f -name "*.txt" -exec readlink -f {} \; | sort -V); do
    color ${MAGENTA} "* * * Installing packages from $(basename ${req_file})"
    ( time "${PRT_ROOT}"/bin/pip install --upgrade --force-reinstall --requirement "${req_file}" ) 2>&1 | indent
    echo
done

# Run customization scripts
for script in $(find ./dev/scripts -type f -name "*.txt" -exec readlink -f {} \; | sort -V); do
    color ${MAGENTA} "* * * Running customization script $(basename ${script})"
    ( time "${script}" ) 2>&1 | indent
    echo
done

echo ">>> Updating dev pip cache object"
(
echo
tar -czf /tmp/${PIP_DEV_CACHE_FILE} -C /root/.cache pip
mv /tmp/${PIP_DEV_CACHE_FILE} ${OUTPUT_DIR}/
echo
) 2>&1 | indent

# Create manifest
"${PRT_ROOT}"/bin/pip list --format=json | jq '{"python_packages": .}' \
    | jq '. += {"python_version": "'${PYTHON_VERSION}'", "runtime_version": "'${RUNTIME_VER}'"}' \
    > "${PRT_ROOT}"/manifest.json

# Create the package archive
color ${MAGENTA} "* * * Creating dev package"
tmpfile="$(mktemp)"
( time (
tar -czf "${tmpfile}" -C "${PRT_ROOT}" $(ls -A "${PRT_ROOT}")
chmod +r "${tmpfile}"
mv "${tmpfile}" "${OUTPUT_DIR}/${PACKAGE_NAME_DEV}"
cp "${PRT_ROOT}/manifest.json" "${OUTPUT_DIR}/${PACKAGE_NAME_DEV%%.*}.manifest.json"
ls -lh "${OUTPUT_DIR}/${PACKAGE_NAME_DEV%%.*}"*
) ) 2>&1 | indent



popd &>/dev/null
exit 0
